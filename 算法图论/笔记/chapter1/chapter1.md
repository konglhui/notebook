# 1.算法简介

## 1.2 二分查找

### 1.2.1更佳查找方式

二分查找是一种算法，其输入是一个有序的元素列表，如要潮州啊的元素包含在列表中，二分查找返回其位置，否则返回null。

- 使用二分查找，每次都排除一半的数字。

- 使用二分查找，最多需要$log_{2}n$步。简单查找需要n步。


二分法代码见binary_serach.py。

### 1.2.2 运行时间

**线性时间（linear time）**最多需要猜测的时间与列表长度相同。

**对数时间（log time）**二分查找的运行时间。

## 1.3 大O表示法

**大O表示法：**是指算法运行的速度有多快。

### 1.3.1 算法的运行时间以不同的速度增加

随着元素数量的增加，二分查找的额外时间并不多，而简单查找需要的额外时间却很多。

大O表示法让你能够比较操作数，它指出了算法运行时间的增速。

### 1.3.2 理解不同的大O运行时间

画包含16个格子的网格

算法一：一个一个画

算法二：折纸，折四次。

算法一运行时间O(n)，算法二的运行时间O(log n)

### 1.3.3 大O表示法指出了最糟糕情况下的运行时间

这是一个保证，你知道运行时间不可能超过O(XX).

（除最糟糕情况下的运行时间，还应考虑平均情况的运行时间。会在第四章讨论）

### 1.3.4一些常见的大O运行时间

- $O(log n$),也叫对数时间，这样的算法包括二分查找。

- $O(n)$,也叫线性时间，这样的算法包括简单查找。

- $O(n*log n)$,这样的算法包括第4章将介绍的快速排序，——一种较快的排序方法

- $O(n_{2})$,这样的算法包括第二章将介绍的选择排序——一种较慢的排序方法

- $O(n!)$,这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。


**启示：**

- 算法的速度指的并非时间，而是操作数的增速。
- 谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。
- 算法的运行时间用大O表示法表示。
- $O(log n$)比$O(n)$快，当需要搜索的元素越多时，前者比后者快得越多。


### 1.3.5 旅行商

挑选出几个城市之间旅程最短的路，需要的运行时间为$O(n!)$.（应该有简便的算法）

## 1.4 小结

- 二分查找的速度比简单查找快得多。

- $O(log n$)比$O(n)$快，当需要搜索的元素越多时，前者比后者快得越多。

- 算法运行时间并不以秒为单位。

- 算法运行时间是从其增速的角度度量的。

- 算法运行时间用大O表示法表示。














