# 第9章 动态规划

## 9.1 背包问题

见书134页

### 9.1.1 简单算法

最简单的算法就是贪婪算法

### 9.1.2 动态规划

见书141页

## 9.2 背包问题FAQ

### 9.2.1 在增加一件商品将如何那

见书143页

### 9.2.2 行的排列顺序发生变化时结果将如何

见书145页

### 9.2.3 可以逐列而不是逐行填充网格吗

见书146页

### 9.2.4 增加一件更小的商品将如何那

见书146页

### 9.2.5 可以偷商品的一部分吗

见书146页

### 9.2.6 旅游路程最优化

见书147页

### 9.2.7 处理相互依赖的情况

动态规划功能强大，他能够解决子问题并使用这些答案来解答大问题。但仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。

### 9,2,8 计算最终的解时会涉及两个以上的子背包吗

为获得前述背包问题的最优解，可能需要偷两件以上的商品。但根据动态规划算法的设计，最多只需合并两个子背包，即根本不会涉及两个以上的子背包。不过这些子背包可能又包含子背包。

### 9.2.9 最优解可能导致背包没装满吗

完全可能，假设偷一颗钻石

## 9.3 最长公共子串

通过前面的动态规划问题，你得到了哪些启示？

- 动态规划可帮助你在给定约束条件下找到最优解。在背包问题中，你必须在背包容量给定的情况下，偷到价值最高的商品。
- 在问题可分解为彼此独立且离散的子问题时，就可使用动态规划来解决。

要设计除动态规划解决方案可能很难，这正是本书要介绍的。

- 每种动态规划解决方案都涉及网格。
- 单元格中的值通常就是你要优化的值，在前面的背包问题中，单元格的值为商品的价值。
- 每个单元格都是子问题，因此你应考虑如何将问题分成子问题，这有助于你找出网格的坐标轴。

### 9.3.1 绘制网格

要确定解决问题的网格，首先要回答如下问题。

- 单元格中的值是什么？
- 如何将这个问题划分为子问题？
- 网格的坐标轴是什么？

### 9.3.2 填充网格

费曼算法：

- （1）将问题写下来。
- （2）好好思考。
- （3）将答案写下来。

### 9.3.3 揭晓答案

![mark](http://p6yio0wew.bkt.clouddn.com/blog/180515/Lf4E260Hc7.png)

``` python
#实现网格的伪代码
if word_a[i] == word_b[j]:
	cell[i][j] = cell[i-1][j-1] + 1
else:
cell[i][j] = 0
```

### 9.3.5 最长公共子序之解决方案

![mark](http://p6yio0wew.bkt.clouddn.com/blog/180515/jjE0CF17Ah.png)

```python
#伪代码
if word_a[i] = word_b[j]:
	cell[i][j] = cell[i-1][j-1] + 1
else:
	cell[i][j] = max(cell[i-1][j],cell[i][j-1])
```

## 9.4 小结

- 需要在给定约束条件下优化某种指标时，动态规划很有用。
- 问题可分解为离散子问题时，可使用动态规划来解决问题。
- 每种动态规划解决方案都涉及网格。
- 单元格中的值通常就是你要优化的值。
- 每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题。
- 没有放之四海皆准的计算动态规划解决方案的公式。









